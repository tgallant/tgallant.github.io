<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tgallant.github.io</title>
    <description>everything lispy</description>		
    <link>https://tgallant.github.io</link>
    <atom:link href="https://tgallant.github.io/feed.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>FreeBSD Home VPN Client Configuration</title>
      <description>&lt;p&gt;&lt;strong&gt;[Note]: Jump &lt;a href=&quot;#pf&quot;&gt;here&lt;/a&gt; if you can't access your computer outside
  of your network with VPN running&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In this post I will walk through the steps of setting up a VPN client on
your FreeBSD desktop/home server. This tutorial assumes that you have
a VPN provider. If you don't have one, I recommend
&lt;a href=&quot;https://privateinternetaccess.com&quot;&gt;privateinternetaccess&lt;/a&gt;.&lt;/p&gt;

&lt;h1&gt;OpenVPN&lt;/h1&gt;

&lt;p&gt;To install OpenVPN, run the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo portmaster security/openvpn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add the following lines to your &lt;code&gt;/etc/rc.conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openvpn_configfile=&quot;/usr/local/etc/openvpn/uswest.ovpn&quot;
openvpn_enable=&quot;YES&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line sets the path for the OpenVPN config file. Change the
path to meet your needs. I recommend copying the config file
provided by your VPN service to &lt;code&gt;/usr/local/etc/openvpn/&lt;/code&gt;. The second
line sets OpenVPN to start at boot time.&lt;/p&gt;

&lt;p&gt;Next, start OpenVPN and enter in your credentials:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service openvpn start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, OpenVPN should be started. You can verify by going to
&lt;a href=&quot;http://canihazip.com&quot;&gt;canihazip.com&lt;/a&gt;. The IP address it shows should
be different than your home IP.&lt;/p&gt;

&lt;p&gt;If you are setting this up on a headless server, you can verify the
VPN is running by executing the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://canihazip.com/s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&quot;pf&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;PF&lt;/h1&gt;

&lt;p&gt;All outbound traffic should now be going through the VPN tunnel. One
drawback of this is that any response to server requests via
your home IP will be routed through the VPN tunnel. This means that
you won't be able to access this computer from outside of your
network. If you want to be able to SSH into your box or utilize any
other service, you'll have to add some PF commands.&lt;/p&gt;

&lt;p&gt;If you already have a &lt;code&gt;pf.config&lt;/code&gt;, add the following were &lt;code&gt;$ext_if&lt;/code&gt; is
your physical interface and &lt;code&gt;$ext_gw&lt;/code&gt; is the internal IP of your router:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pass in quick on $ext_if reply-to($ext_if $ext_gw) proto icmp to $int_ip keep state
pass in quick on $ext_if reply-to($ext_if $ext_gw) proto tcp to $int_ip port 22 keep state
pass in on $ext_if reply-to($ext_if $ext_gw) to $int_ip keep state
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This configuration will allow your server to respond to pings and
accept SSH connections through your home IP. Copy the second line and
change the port if you want to open other ports.&lt;/p&gt;

&lt;p&gt;If you don't have a config, copy the file below and paste it in
&lt;code&gt;/etc/pf.conf&lt;/code&gt;. Make sure the interface names match for your system.
For &lt;code&gt;$ext_gw&lt;/code&gt; use the internal IP of your router and for &lt;code&gt;$int_ip&lt;/code&gt; use
the internal IP address of your computer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
# vim: set ft=pf
# /etc/pf.conf

ext_if = &quot;em0&quot; # physical interface
tun_if = &quot;tun0&quot; # vpn tunnel interface
ext_gw = &quot;xxx.xxx.xxx.xxx&quot; # ip address of the router
int_ip = &quot;xxx.xxx.xxx.xxx&quot; # ip address of this machine

icmp_types_ext_if=&quot;{ echoreq }&quot; # ping

set loginterface $ext_if

### normalization
scrub in all random-id fragment reassemble

set skip on lo0

block return in log all
block out all

antispoof quick for $ext_if

### block anything coming from sources that we have no back routes for.
block in from no-route to any

block in from urpf-failed to any

### drop broadcast requests quietly.
block in quick on $ext_if from any to 255.255.255.255
block in quick on $ext_if proto tcp flags FUP/WEUAPRSF
block in quick on $ext_if proto tcp flags WEUAPRSF/WEUAPRSF
block in quick on $ext_if proto tcp flags SRAFU/WEUAPRSF
block in quick on $ext_if proto tcp flags /WEUAPRSF
block in quick on $ext_if proto tcp flags SR/SR
block in quick on $ext_if proto tcp flags SF/SF

### allow outbound traffic
pass out on $ext_if proto { tcp, udp, icmp } from any to any modulate state
pass out on $tun_if proto { tcp, udp, icmp } from any to any modulate state

### allow inbound traffic, routing responses to the physical interface
pass in quick on $ext_if reply-to($ext_if $ext_gw) proto icmp to $int_ip keep state
pass in quick on $ext_if reply-to($ext_if $ext_gw) proto tcp to $int_ip port 22 keep state
pass in on $ext_if reply-to($ext_if $ext_gw) to $int_ip keep state
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Now we'll have to enable pf and start the service. To
enable pf, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo echo 'pf_enable=&quot;YES&quot;' &amp;gt;&amp;gt; /etc/rc.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To start pf, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service pf start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should now have a working VPN connection and a pf configuration
that allows you to access this computer from outside your
network. If you have any comments or questions, let me know below.&lt;/p&gt;
</description>
      <pubDate>Mon, 15 Dec 2014 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/nix/freebsd-home-vpn-configuration.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/nix/freebsd-home-vpn-configuration.html</guid>
    </item>
    
    <item>
      <title>Manage Clojure Processes with supervisord</title>
      <description>&lt;p&gt;Writing init scripts can be a pain and running your apps in tmux or screen sessions, while easier, seems unprofessional. That's where supervisord comes in. Supervisord provides an easy way to define and manage processes. It seems to be more well known in the python world, but it can be used to run any command on your system path.&lt;/p&gt;

&lt;p&gt;Installing supervisord is easy. You can run &lt;code&gt;apt-get install supervisor&lt;/code&gt; or &lt;code&gt;yum install supervisor&lt;/code&gt; if you're on debian/redhat. If your distribution doesn't offer supervisor in it's packcage manager, you can install it via &lt;code&gt;pip install supervisor&lt;/code&gt;. More info about installation can be found &lt;a href=&quot;http://supervisord.org/installing.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To have supervisord manage a ring app, place the following in &lt;code&gt;/etc/supervisor/conf.d&lt;/code&gt;. Be sure to change out the program name, paths, and user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
[program:blog-checker]
command= /usr/local/bin/java -jar target/blog-checker-0.1.0-SNAPSHOT-standalone.jar
directory=/usr/local/www/blog-checker
autostart=true
autorestart=true
startretries=3
user=www
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The above configuration executes &lt;code&gt;/usr/local/bin/java -jar target/blog-checker-0.1.0-SNAPSHOT-standalone.jar&lt;/code&gt; as the user &lt;code&gt;www&lt;/code&gt; in the &lt;code&gt;/usr/local/www/blog-checker&lt;/code&gt; directory. Lines 4-6 set this app to be run at startup and to autorestart if it fails.&lt;/p&gt;

&lt;p&gt;To start the app, run &lt;code&gt;supervisorctl reread &amp;amp;&amp;amp; supervisorctl update &amp;amp;&amp;amp; supervisorctl start &amp;lt;your_app_name_here&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also run &lt;code&gt;supervisorctl status&lt;/code&gt; to check the status of your app or &lt;code&gt;supervisorctl restart &amp;lt;your_app_name_here&amp;gt;&lt;/code&gt; to restart it.&lt;/p&gt;
</description>
      <pubDate>Sat, 01 Nov 2014 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/clojure/supervisord-with-clojure.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/clojure/supervisord-with-clojure.html</guid>
    </item>
    
    <item>
      <title>Grunt Livereload for Clojurescript</title>
      <description>&lt;p&gt;&lt;a href=&quot;https://github.com/tgallant/cljs-livereload-example/blob/master/Gruntfile.js&quot;&gt;Link to Gruntfile.js if you know what you're doing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The front-end tooling ecosystem that has emerged around node allows for many modern niceties like npm, bower, and grunt. As helpful as these tools can be, they can also bring about a boiling, unfathomable rage when they stop working or, perhaps, don't work at all. See the following tweet from Joe Armstrong, creator of erlang and all-around badass&lt;/p&gt;

&lt;center&gt;
&lt;blockquote class=&quot;twitter-tweet&quot; lang=&quot;en&quot;&gt;&lt;p&gt;&amp;quot;Unable to find local grunt&amp;quot; - but I just installed grunt - Aaaaaaggggg - &amp;#10;having a bad day ...&lt;/p&gt;&amp;mdash; Joe Armstrong (@joeerl) &lt;a href=&quot;https://twitter.com/joeerl/status/505337612513853441&quot;&gt;August 29, 2014&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/center&gt;


&lt;p&gt;Joe's Gruntrage&amp;trade; led him to mention this experience in his aptly titled talk, &lt;a href=&quot;https://www.youtube.com/watch?v=lKXe3HUG2l4&quot;&gt;The Mess We're In&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, this isn't a post about bashing grunt or node. I actually advocate for their use and think grunt can allow for some pretty awesome clojurescript workflows. I will show you how to get started with a livereload clojurescript workflow and make sure you don't have any &quot;bad days.&quot;&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/tgallant/cljs-livereload-example&quot;&gt;Here&lt;/a&gt; is a working github repo if you need help or just want to get started right away.&lt;/p&gt;

&lt;p&gt;Start by creating a new clojure project by running &lt;code&gt;lein new app example&lt;/code&gt;. Once that is complete, edit &lt;code&gt;project.clj&lt;/code&gt; so it looks like the following. Be sure to include any other dependencies you will need. The main things to keep an eye on here are the inclusion of &lt;code&gt;lein-cljsbuild&lt;/code&gt; and the paths for &lt;code&gt;:output-to&lt;/code&gt; and &lt;code&gt;:output-dir&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(defproject example &quot;0.1.0-SNAPSHOT&quot;
  :description &quot;FIXME: write description&quot;
  :url &quot;http://example.com/FIXME&quot;
  :license {:name &quot;Eclipse Public License&quot;
            :url &quot;http://www.eclipse.org/legal/epl-v10.html&quot;}
 
  :jvm-opts ^:replace [&quot;-Xmx1g&quot; &quot;-server&quot;]
 
  :dependencies [[org.clojure/clojure &quot;1.6.0&quot;]
                 [org.clojure/clojurescript &quot;0.0-2371&quot;]]
 
  :plugins [[lein-cljsbuild &quot;1.0.3&quot;]]
 
  :source-paths [&quot;src/&quot;]
  :resource-paths [&quot;resources&quot;]
 
  :cljsbuild {
    :builds [{:id &quot;dev&quot;
              :source-paths [&quot;src/&quot;]
              :compiler {
                :output-to &quot;resources/public/scripts/main.js&quot;
                :output-dir &quot;resources/public/scripts/out&quot;
                :optimizations :none
                :source-map true}}]})
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Next, install node and npm if you don't have them already. For ubuntu/debian based distros, run &lt;code&gt;sudo apt-get install npm&lt;/code&gt;. This will rope in node and all of the other packages you'll need to get started. Next, install grunt by running &lt;code&gt;sudo npm install -g grunt-cli&lt;/code&gt;. Once you have node, npm, and grunt, create a file called &lt;code&gt;package.json&lt;/code&gt; in your project directory and add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
{
  &quot;name&quot;: &quot;example&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;devDependencies&quot;: {},
  &quot;dependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.5&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.6.1&quot;,
    &quot;grunt-express&quot;: &quot;~1.4.1&quot;,
    &quot;grunt-open&quot;: &quot;~0.2.3&quot;,
    &quot;matchdep&quot;: &quot;~0.3.0&quot;
  },
 &quot;engines&quot;: {
   &quot;node&quot;: &quot;&gt;=0.8.0&quot;
 }
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This file lists the node dependencies you'll need to enable livereload. Run &lt;code&gt;npm install&lt;/code&gt; in your project directory to install them locally.&lt;/p&gt;

&lt;p&gt;Now for the fun part. Create a file called &lt;code&gt;Gruntfile.js&lt;/code&gt; in your project directory and add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Gruntfile
module.exports = function(grunt) {
 
  require('matchdep').filter('grunt-*').forEach(grunt.loadNpmTasks);
 
  // Configure Grunt
  grunt.initConfig({
 
      // grunt-express will serve the files from the folders listed in `bases`
      // on specified `port` and `hostname`
      express: {
        all: {
          options: {
            port: 9000,
            hostname: &quot;0.0.0.0&quot;,
            bases: ['resources/public/'],
            livereload: true
          }
        }
      },
 
      // grunt-watch will monitor the projects files
      watch: {
        all: {
          files: ['resources/public/*',
                  '!**/bower_components/**'],
          options: {
            livereload: true
          }
        }
      },
 
      // grunt-open will open your browser at the project's URL
      open: {
        all: {
          // Gets the port from the connect configuration
          path: 'http://127.0.0.1:&lt;%= express.all.options.port%&gt;'
        }
      }
  });
 
  // Creates the `lein` task
  grunt.registerTask('lein', 'compile cljs.', function() {
    var spawn = require('child_process').spawn;
    grunt.log.writeln('Compiling cljs.');
    var PIPE = {stdio: 'inherit'};
    spawn('lein', ['cljsbuild', 'auto'], PIPE);
  });
 
 // Creates the `server` task
  grunt.registerTask('server', [
    'lein',
    'express',
    'open',
    'watch'
  ]);
};
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This configuration will allow you to compile your clojurescript, automatically open the app in your browser, and recompile/refresh your browser when you make a change.&lt;/p&gt;

&lt;p&gt;Let's write some really quick clojurescript to get you started.&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;First, in your project directory, run &lt;code&gt;mkdir -p resources/public/scripts&lt;/code&gt; and create a new file at &lt;code&gt;resources/public/index.html&lt;/code&gt;. Make sure your index.html looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script src=&quot;scripts/out/goog/base.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;scripts/main.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;goog.require(&quot;example.core&quot;);&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, create a new file at &lt;code&gt;src/example/core.cljs&lt;/code&gt; and add the following&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(ns example.core)
 
(enable-console-print!)
 
(.log js/console &quot;Hello!&quot;)
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Before you start the livereload, run &lt;code&gt;lein cljsbuild once&lt;/code&gt; so you don't have to wait for the code to compile when you launch the server for the first time. Once that's complete, run &lt;code&gt;grunt server&lt;/code&gt; in your project directory and let the grunt magic do the rest. Open the javascript console in your browser and you should see &quot;Hello!&quot;. Modify &lt;code&gt;src/example/core.cljs&lt;/code&gt;, save it, and watch your code compile and refresh in your browser! Pretty cool.&lt;/p&gt;
</description>
      <pubDate>Sun, 19 Oct 2014 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/clojure/grunt-livereload-for-clojurescript.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/clojure/grunt-livereload-for-clojurescript.html</guid>
    </item>
    
  </channel>
</rss>
