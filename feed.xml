<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tgallant.github.io</title>
    <description>functional programming and web dev</description>		
    <link>https://tgallant.github.io</link>
    <atom:link href="https://tgallant.github.io/feed.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Spam Referral Links in Google Analytics</title>
      <description>&lt;p&gt;I&#39;ve been getting spam referral links in Google Analytics for a few
months now. It is a bit annoying but I didn&#39;t think anything of it.
Recently though, I noticed that these spammers are evolving.&lt;/p&gt;

&lt;p&gt;Here is a screenshot from a few months ago.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wut00.png&quot; height=&quot;200px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here is a screenshot from last month.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wut0.png&quot; height=&quot;200px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This one really caught my attention. I actually clicked through to see
what it was. Who knows, some website like that might exist and have
came across my site. I felt betrayed when I was redirected to the
click bait-y  ilovevitaly.ru.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wut1.png&quot; height=&quot;50px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wut2.png&quot; height=&quot;50px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;These sites exist to make money for their owners. They make bogus
page views on your site and hope that you&#39;ll click through to their
site when you see it in your analytics. To me this new wave of domains
making spam referral links has gone a bit too far. I&#39;d hate for this
to continue to grow.&lt;/p&gt;
</description>
      <pubDate>Sat, 07 Feb 2015 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/web/spam-referrals-in-google-analytics.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/web/spam-referrals-in-google-analytics.html</guid>
    </item>
    
    <item>
      <title>html5Mode in Angular and Clojure</title>
      <description>&lt;ul&gt;
&lt;li&gt;benefits of angularjs html5mode

&lt;ul&gt;
&lt;li&gt;native looking urls&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;drawbacks of html5mode

&lt;ul&gt;
&lt;li&gt;not sharable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;solutions

&lt;ul&gt;
&lt;li&gt;send all traffic to index.hmtl&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tgallant/angular-seed-clj&quot;&gt;https://github.com/tgallant/angular-seed-clj&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Its probably a purely aesthetic thing, but I&#39;m not a big fan of the
default angularjs urls. I feel having the &#39;#&#39; in there hinders
usability. A project&#39;s url structure is more discoverable when it is
familiar to the user. This is where html5Mode can be handy. It will
turn your urls from this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /home/#/dashboard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /home/dashboard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gets us the url structure we want, but these links are in fact
not sharable. If your application is using html5Mode, the url that
shows up in the browser can&#39;t be copy and pasted. Instead of bringing
up the requested page it will throw a 404. This is because the server
is not aware that angular is controlling all of the routes. To get
sharable links with html5Mode the server needs to let angular handle
the application routing.&lt;/p&gt;

&lt;p&gt;In nginx this is done by using &lt;code&gt;try_files&lt;/code&gt; like so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
  root /path/to/files;
  try_files $uri $uri/ /index.html;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If nginx doesn&#39;t get a valid response from the actual url path, it
will send the request to the index.html file, at which point angularjs
will initialize and handle the url parameters. This is a handy trick
that we can actually implement in our server-side code.&lt;/p&gt;

&lt;p&gt;In compojure this is done by specifying a wildcard route like so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defroutes app-routes
  (GET &quot;/&quot; [] (index-page))
  (GET &quot;/api/repo/&quot; [] (api/repo-info))
  (POST &quot;/api/init/&quot; request (api/new-repo (get-in request [:body :name])))
  (GET &quot;*&quot; [] (index-page))
  (route/resources &quot;/&quot;)
  (route/not-found &quot;Not Found&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In compojure the asterisk stands for the wildcard route. It will match
any route that has not yet been matched. When using wildcards it is
important to put them after all of your defined routes like in the
example above. If a route is defined after the wildcard it will never
be run.&lt;/p&gt;

&lt;p&gt;I really like how this clojure/angularjs html5mode setup separates the
concerns of API routes and application routes. Angular takes care of
all browser facing routes while clojure deals with API routes and
database calls. All of this while maintaining our nice clean URI
structure. Hashtags belong on twitter, not in urls!&lt;/p&gt;

&lt;p&gt;I&#39;ve put together a github repo with all of this stuff already setup. Check it
out here &lt;a href=&quot;https://github.com/tgallant/angular-seed-clj&quot;&gt;https://github.com/tgallant/angular-seed-clj&lt;/a&gt;.&lt;/p&gt;
</description>
      <pubDate>Tue, 20 Jan 2015 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/clojure/html5Mode-angular-clojure.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/clojure/html5Mode-angular-clojure.html</guid>
    </item>
    
    <item>
      <title>Overriding Push/Pull in Foundation</title>
      <description>&lt;p&gt;&lt;a href=&quot;http://jsfiddle.net/z54p61wh/1/&quot;&gt;example of the problem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jsfiddle.net/p97zymha/&quot;&gt;example of the solution&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you are stuck using older versions of foundation, medium-push/pull
will override the default positioning for &lt;code&gt;large-#&lt;/code&gt; blocks. To fix this
you can use media queries to set them back to normal.&lt;/p&gt;

&lt;p&gt;In the example below, small and large screens will stack the divs
vertically. Then, medium screens will stack the divs horizontally with
their order switched.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;iBox&quot;&amp;gt;
  &amp;lt;div class=&quot;row&quot; style=&quot;margin: 0;&quot;&amp;gt;
    &amp;lt;div class=&quot;imgWrapper small-12 medium-6 medium-push-6 large-12 columns&quot;&amp;gt;
      &amp;lt;h1&amp;gt;hello&amp;lt;/h1&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;contentWrapper small-12 medium-6 medium-pull-6 large-12 columns&quot;&amp;gt;
      &amp;lt;div class=&quot;content&quot;&amp;gt;
        &amp;lt;h1&amp;gt;there&amp;lt;/h1&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
/*** Desktop ***/ 
@media only screen and (min-width: 64.063em) {
    .iBox .imgWrapper {
      left:0%;
    }
    .iBox .contentWrapper {
      right:0%;
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      <pubDate>Wed, 07 Jan 2015 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/web/overriding-push-pull-in-foundation.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/web/overriding-push-pull-in-foundation.html</guid>
    </item>
    
    <item>
      <title>FreeBSD Home VPN Client Configuration</title>
      <description>&lt;p&gt;&lt;strong&gt;[Note]: Jump &lt;a href=&quot;#pf&quot;&gt;here&lt;/a&gt; if you can&#39;t access your computer outside
  of your network with VPN running&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In this post I will walk through the steps of setting up a VPN client on
your FreeBSD desktop/home server. This tutorial assumes that you have
a VPN provider. If you don&#39;t have one, I recommend
&lt;a href=&quot;https://privateinternetaccess.com&quot;&gt;privateinternetaccess&lt;/a&gt;.&lt;/p&gt;

&lt;h1&gt;OpenVPN&lt;/h1&gt;

&lt;p&gt;To install OpenVPN, run the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo portmaster security/openvpn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add the following lines to your &lt;code&gt;/etc/rc.conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openvpn_configfile=&quot;/usr/local/etc/openvpn/uswest.ovpn&quot;
openvpn_enable=&quot;YES&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line sets the path for the OpenVPN config file. Change the
path to meet your needs. I recommend copying the config file
provided by your VPN service to &lt;code&gt;/usr/local/etc/openvpn/&lt;/code&gt;. The second
line sets OpenVPN to start at boot time.&lt;/p&gt;

&lt;p&gt;Next, start OpenVPN and enter in your credentials:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service openvpn start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, OpenVPN should be started. You can verify by going to
&lt;a href=&quot;http://canihazip.com&quot;&gt;canihazip.com&lt;/a&gt;. The IP address it shows should
be different than your home IP.&lt;/p&gt;

&lt;p&gt;If you are setting this up on a headless server, you can verify the
VPN is running by executing the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://canihazip.com/s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&quot;pf&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;PF&lt;/h1&gt;

&lt;p&gt;All outbound traffic should now be going through the VPN tunnel. One
drawback of this is that any response to server requests via
your home IP will be routed through the VPN tunnel. This means that
you won&#39;t be able to access this computer from outside of your
network. If you want to be able to SSH into your box or utilize any
other service, you&#39;ll have to add some PF commands.&lt;/p&gt;

&lt;p&gt;If you already have a &lt;code&gt;pf.config&lt;/code&gt;, add the following were &lt;code&gt;$ext_if&lt;/code&gt; is
your physical interface and &lt;code&gt;$ext_gw&lt;/code&gt; is the internal IP of your router:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pass in quick on $ext_if reply-to($ext_if $ext_gw) proto icmp to $int_ip keep state
pass in quick on $ext_if reply-to($ext_if $ext_gw) proto tcp to $int_ip port 22 keep state
pass in on $ext_if reply-to($ext_if $ext_gw) to $int_ip keep state
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This configuration will allow your server to respond to pings and
accept SSH connections through your home IP. Copy the second line and
change the port if you want to open other ports.&lt;/p&gt;

&lt;p&gt;If you don&#39;t have a config, copy the file below and paste it in
&lt;code&gt;/etc/pf.conf&lt;/code&gt;. Make sure the interface names match for your system.
For &lt;code&gt;$ext_gw&lt;/code&gt; use the internal IP of your router and for &lt;code&gt;$int_ip&lt;/code&gt; use
the internal IP address of your computer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
# vim: set ft=pf
# /etc/pf.conf

ext_if = &quot;em0&quot; # physical interface
tun_if = &quot;tun0&quot; # vpn tunnel interface
ext_gw = &quot;xxx.xxx.xxx.xxx&quot; # ip address of the router
int_ip = &quot;xxx.xxx.xxx.xxx&quot; # ip address of this machine

icmp_types_ext_if=&quot;{ echoreq }&quot; # ping

set loginterface $ext_if

### normalization
scrub in all random-id fragment reassemble

set skip on lo0

block return in log all
block out all

antispoof quick for $ext_if

### block anything coming from sources that we have no back routes for.
block in from no-route to any

block in from urpf-failed to any

### drop broadcast requests quietly.
block in quick on $ext_if from any to 255.255.255.255
block in quick on $ext_if proto tcp flags FUP/WEUAPRSF
block in quick on $ext_if proto tcp flags WEUAPRSF/WEUAPRSF
block in quick on $ext_if proto tcp flags SRAFU/WEUAPRSF
block in quick on $ext_if proto tcp flags /WEUAPRSF
block in quick on $ext_if proto tcp flags SR/SR
block in quick on $ext_if proto tcp flags SF/SF

### allow outbound traffic
pass out on $ext_if proto { tcp, udp, icmp } from any to any modulate state
pass out on $tun_if proto { tcp, udp, icmp } from any to any modulate state

### allow inbound traffic, routing responses to the physical interface
pass in quick on $ext_if reply-to($ext_if $ext_gw) proto icmp to $int_ip keep state
pass in quick on $ext_if reply-to($ext_if $ext_gw) proto tcp to $int_ip port 22 keep state
pass in on $ext_if reply-to($ext_if $ext_gw) to $int_ip keep state
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Now we&#39;ll have to enable pf and start the service. To
enable pf, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo echo &#39;pf_enable=&quot;YES&quot;&#39; &amp;gt;&amp;gt; /etc/rc.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To start pf, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service pf start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should now have a working VPN connection and a pf configuration
that allows you to access this computer from outside your
network. If you have any comments or questions, let me know below.&lt;/p&gt;
</description>
      <pubDate>Mon, 15 Dec 2014 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/nix/freebsd-home-vpn-configuration.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/nix/freebsd-home-vpn-configuration.html</guid>
    </item>
    
    <item>
      <title>Manage Clojure Processes with supervisord</title>
      <description>&lt;p&gt;Writing init scripts can be a pain and running your apps in tmux or screen sessions, while easier, seems unprofessional. That&#39;s where supervisord comes in. Supervisord provides an easy way to define and manage processes. It seems to be more well known in the python world, but it can be used to run any command on your system path.&lt;/p&gt;

&lt;p&gt;Installing supervisord is easy. You can run &lt;code&gt;apt-get install supervisor&lt;/code&gt; or &lt;code&gt;yum install supervisor&lt;/code&gt; if you&#39;re on debian/redhat. If your distribution doesn&#39;t offer supervisor in it&#39;s packcage manager, you can install it via &lt;code&gt;pip install supervisor&lt;/code&gt;. More info about installation can be found &lt;a href=&quot;http://supervisord.org/installing.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To have supervisord manage a ring app, place the following in &lt;code&gt;/etc/supervisor/conf.d&lt;/code&gt;. Be sure to change out the program name, paths, and user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
[program:blog-checker]
command= /usr/local/bin/java -jar target/blog-checker-0.1.0-SNAPSHOT-standalone.jar
directory=/usr/local/www/blog-checker
autostart=true
autorestart=true
startretries=3
user=www
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The above configuration executes &lt;code&gt;/usr/local/bin/java -jar target/blog-checker-0.1.0-SNAPSHOT-standalone.jar&lt;/code&gt; as the user &lt;code&gt;www&lt;/code&gt; in the &lt;code&gt;/usr/local/www/blog-checker&lt;/code&gt; directory. Lines 4-6 set this app to be run at startup and to autorestart if it fails.&lt;/p&gt;

&lt;p&gt;To start the app, run &lt;code&gt;supervisorctl reread &amp;amp;&amp;amp; supervisorctl update &amp;amp;&amp;amp; supervisorctl start &amp;lt;your_app_name_here&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also run &lt;code&gt;supervisorctl status&lt;/code&gt; to check the status of your app or &lt;code&gt;supervisorctl restart &amp;lt;your_app_name_here&amp;gt;&lt;/code&gt; to restart it.&lt;/p&gt;
</description>
      <pubDate>Sat, 01 Nov 2014 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/clojure/supervisord-with-clojure.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/clojure/supervisord-with-clojure.html</guid>
    </item>
    
    <item>
      <title>Grunt Livereload for Clojurescript</title>
      <description>&lt;p&gt;&lt;a href=&quot;https://github.com/tgallant/cljs-livereload-example/blob/master/Gruntfile.js&quot;&gt;Link to Gruntfile.js if you know what you&#39;re doing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The front-end tooling ecosystem that has emerged around node allows for many modern niceties like npm, bower, and grunt. As helpful as these tools can be, they can also bring about a boiling, unfathomable rage when they stop working or, perhaps, don&#39;t work at all. See the following tweet from Joe Armstrong, creator of erlang and all-around badass&lt;/p&gt;

&lt;center&gt;
&lt;blockquote class=&quot;twitter-tweet&quot; lang=&quot;en&quot;&gt;&lt;p&gt;&amp;quot;Unable to find local grunt&amp;quot; - but I just installed grunt - Aaaaaaggggg - &amp;#10;having a bad day ...&lt;/p&gt;&amp;mdash; Joe Armstrong (@joeerl) &lt;a href=&quot;https://twitter.com/joeerl/status/505337612513853441&quot;&gt;August 29, 2014&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/center&gt;


&lt;p&gt;Joe&#39;s Gruntrage&amp;trade; led him to mention this experience in his aptly titled talk, &lt;a href=&quot;https://www.youtube.com/watch?v=lKXe3HUG2l4&quot;&gt;The Mess We&#39;re In&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, this isn&#39;t a post about bashing grunt or node. I actually advocate for their use and think grunt can allow for some pretty awesome clojurescript workflows. I will show you how to get started with a livereload clojurescript workflow and make sure you don&#39;t have any &quot;bad days.&quot;&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/tgallant/cljs-livereload-example&quot;&gt;Here&lt;/a&gt; is a working github repo if you need help or just want to get started right away.&lt;/p&gt;

&lt;p&gt;Start by creating a new clojure project by running &lt;code&gt;lein new app example&lt;/code&gt;. Once that is complete, edit &lt;code&gt;project.clj&lt;/code&gt; so it looks like the following. Be sure to include any other dependencies you will need. The main things to keep an eye on here are the inclusion of &lt;code&gt;lein-cljsbuild&lt;/code&gt; and the paths for &lt;code&gt;:output-to&lt;/code&gt; and &lt;code&gt;:output-dir&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(defproject example &quot;0.1.0-SNAPSHOT&quot;
  :description &quot;FIXME: write description&quot;
  :url &quot;http://example.com/FIXME&quot;
  :license {:name &quot;Eclipse Public License&quot;
            :url &quot;http://www.eclipse.org/legal/epl-v10.html&quot;}
 
  :jvm-opts ^:replace [&quot;-Xmx1g&quot; &quot;-server&quot;]
 
  :dependencies [[org.clojure/clojure &quot;1.6.0&quot;]
                 [org.clojure/clojurescript &quot;0.0-2371&quot;]]
 
  :plugins [[lein-cljsbuild &quot;1.0.3&quot;]]
 
  :source-paths [&quot;src/&quot;]
  :resource-paths [&quot;resources&quot;]
 
  :cljsbuild {
    :builds [{:id &quot;dev&quot;
              :source-paths [&quot;src/&quot;]
              :compiler {
                :output-to &quot;resources/public/scripts/main.js&quot;
                :output-dir &quot;resources/public/scripts/out&quot;
                :optimizations :none
                :source-map true}}]})
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Next, install node and npm if you don&#39;t have them already. For ubuntu/debian based distros, run &lt;code&gt;sudo apt-get install npm&lt;/code&gt;. This will rope in node and all of the other packages you&#39;ll need to get started. Next, install grunt by running &lt;code&gt;sudo npm install -g grunt-cli&lt;/code&gt;. Once you have node, npm, and grunt, create a file called &lt;code&gt;package.json&lt;/code&gt; in your project directory and add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
{
  &quot;name&quot;: &quot;example&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;devDependencies&quot;: {},
  &quot;dependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.5&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.6.1&quot;,
    &quot;grunt-express&quot;: &quot;~1.4.1&quot;,
    &quot;grunt-open&quot;: &quot;~0.2.3&quot;,
    &quot;matchdep&quot;: &quot;~0.3.0&quot;
  },
 &quot;engines&quot;: {
   &quot;node&quot;: &quot;&gt;=0.8.0&quot;
 }
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This file lists the node dependencies you&#39;ll need to enable livereload. Run &lt;code&gt;npm install&lt;/code&gt; in your project directory to install them locally.&lt;/p&gt;

&lt;p&gt;Now for the fun part. Create a file called &lt;code&gt;Gruntfile.js&lt;/code&gt; in your project directory and add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Gruntfile
module.exports = function(grunt) {
 
  require(&#39;matchdep&#39;).filter(&#39;grunt-*&#39;).forEach(grunt.loadNpmTasks);
 
  // Configure Grunt
  grunt.initConfig({
 
      // grunt-express will serve the files from the folders listed in `bases`
      // on specified `port` and `hostname`
      express: {
        all: {
          options: {
            port: 9000,
            hostname: &quot;0.0.0.0&quot;,
            bases: [&#39;resources/public/&#39;],
            livereload: true
          }
        }
      },
 
      // grunt-watch will monitor the projects files
      watch: {
        all: {
          files: [&#39;resources/public/*&#39;,
                  &#39;!**/bower_components/**&#39;],
          options: {
            livereload: true
          }
        }
      },
 
      // grunt-open will open your browser at the project&#39;s URL
      open: {
        all: {
          // Gets the port from the connect configuration
          path: &#39;http://127.0.0.1:&lt;%= express.all.options.port%&gt;&#39;
        }
      }
  });
 
  // Creates the `lein` task
  grunt.registerTask(&#39;lein&#39;, &#39;compile cljs.&#39;, function() {
    var spawn = require(&#39;child_process&#39;).spawn;
    grunt.log.writeln(&#39;Compiling cljs.&#39;);
    var PIPE = {stdio: &#39;inherit&#39;};
    spawn(&#39;lein&#39;, [&#39;cljsbuild&#39;, &#39;auto&#39;], PIPE);
  });
 
 // Creates the `server` task
  grunt.registerTask(&#39;server&#39;, [
    &#39;lein&#39;,
    &#39;express&#39;,
    &#39;open&#39;,
    &#39;watch&#39;
  ]);
};
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This configuration will allow you to compile your clojurescript, automatically open the app in your browser, and recompile/refresh your browser when you make a change.&lt;/p&gt;

&lt;p&gt;Let&#39;s write some really quick clojurescript to get you started.&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;First, in your project directory, run &lt;code&gt;mkdir -p resources/public/scripts&lt;/code&gt; and create a new file at &lt;code&gt;resources/public/index.html&lt;/code&gt;. Make sure your index.html looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script src=&quot;scripts/out/goog/base.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;scripts/main.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;goog.require(&quot;example.core&quot;);&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, create a new file at &lt;code&gt;src/example/core.cljs&lt;/code&gt; and add the following&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(ns example.core)
 
(enable-console-print!)
 
(.log js/console &quot;Hello!&quot;)
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Before you start the livereload, run &lt;code&gt;lein cljsbuild once&lt;/code&gt; so you don&#39;t have to wait for the code to compile when you launch the server for the first time. Once that&#39;s complete, run &lt;code&gt;grunt server&lt;/code&gt; in your project directory and let the grunt magic do the rest. Open the javascript console in your browser and you should see &quot;Hello!&quot;. Modify &lt;code&gt;src/example/core.cljs&lt;/code&gt;, save it, and watch your code compile and refresh in your browser! Pretty cool.&lt;/p&gt;
</description>
      <pubDate>Sun, 19 Oct 2014 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/clojure/grunt-livereload-for-clojurescript.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/clojure/grunt-livereload-for-clojurescript.html</guid>
    </item>
    
  </channel>
</rss>
