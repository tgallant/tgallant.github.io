<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tgallant.github.io</title>
    <description>everything lispy</description>		
    <link>https://tgallant.github.io</link>
    <atom:link href="https://tgallant.github.io/feed.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Manage Clojure Processes with supervisord</title>
      <description>&lt;p&gt;Writing init scripts can be a pain and running your apps in tmux or screen sessions, while easier, seems unprofessional. That&#39;s where supervisord comes in. Supervisord provides an easy way to define and manage processes. It seems to be more well known in the python world, but it can be used to run any command on your system path.&lt;/p&gt;

&lt;p&gt;Installing supervisord is easy. You can run &lt;code&gt;apt-get install supervisor&lt;/code&gt; or &lt;code&gt;yum install supervisor&lt;/code&gt; if you&#39;re on debian/redhat. If your distribution doesn&#39;t offer supervisor in it&#39;s packcage manager, you can install it via &lt;code&gt;pip install supervisor&lt;/code&gt;. More info about installation can be found &lt;a href=&quot;http://supervisord.org/installing.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To have supervisord manage a ring app, place the following in &lt;code&gt;/etc/supervisor/conf.d&lt;/code&gt;. Be sure to change out the program name, paths, and user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
[program:blog-checker]
command= /usr/local/bin/java -jar target/blog-checker-0.1.0-SNAPSHOT-standalone.jar
directory=/usr/local/www/blog-checker
autostart=true
autorestart=true
startretries=3
user=www
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The above configuration executes &lt;code&gt;/usr/local/bin/java -jar target/blog-checker-0.1.0-SNAPSHOT-standalone.jar&lt;/code&gt; as the user &lt;code&gt;www&lt;/code&gt; in the &lt;code&gt;/usr/local/www/blog-checker&lt;/code&gt; directory. Lines 4-6 set this app to be run at startup and to autorestart if it fails.&lt;/p&gt;

&lt;p&gt;To start the app, run &lt;code&gt;supervisorctl reread &amp;amp;&amp;amp; supervisorctl update &amp;amp;&amp;amp; supervisorctl start &amp;lt;your_app_name_here&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also run &lt;code&gt;supervisorctl status&lt;/code&gt; to check the status of your app or &lt;code&gt;supervisorctl restart &amp;lt;your_app_name_here&amp;gt;&lt;/code&gt; to restart it.&lt;/p&gt;
</description>
      <pubDate>Sat, 01 Nov 2014 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/clojure/supervisord-with-clojure.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/clojure/supervisord-with-clojure.html</guid>
    </item>
    
    <item>
      <title>Grunt Livereload for Clojurescript</title>
      <description>&lt;p&gt;&lt;a href=&quot;https://github.com/tgallant/cljs-livereload-example/blob/master/Gruntfile.js&quot;&gt;Link to Gruntfile.js if you know what you&#39;re doing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The front-end tooling ecosystem that has emerged around node allows for many modern niceties like npm, bower, and grunt. As helpful as these tools can be, they can also bring about a boiling, unfathomable rage when they stop working or, perhaps, don&#39;t work at all. See the following tweet from Joe Armstrong, creator of erlang and all-around badass&lt;/p&gt;

&lt;center&gt;
&lt;blockquote class=&quot;twitter-tweet&quot; lang=&quot;en&quot;&gt;&lt;p&gt;&amp;quot;Unable to find local grunt&amp;quot; - but I just installed grunt - Aaaaaaggggg - &amp;#10;having a bad day ...&lt;/p&gt;&amp;mdash; Joe Armstrong (@joeerl) &lt;a href=&quot;https://twitter.com/joeerl/status/505337612513853441&quot;&gt;August 29, 2014&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/center&gt;


&lt;p&gt;Joe&#39;s Gruntrage&amp;trade; led him to mention this experience in his aptly titled talk, &lt;a href=&quot;https://www.youtube.com/watch?v=lKXe3HUG2l4&quot;&gt;The Mess We&#39;re In&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, this isn&#39;t a post about bashing grunt or node. I actually advocate for their use and think grunt can allow for some pretty awesome clojurescript workflows. I will show you how to get started with a livereload clojurescript workflow and make sure you don&#39;t have any &quot;bad days.&quot;&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/tgallant/cljs-livereload-example&quot;&gt;Here&lt;/a&gt; is a working github repo if you need help or just want to get started right away.&lt;/p&gt;

&lt;p&gt;Start by creating a new clojure project by running &lt;code&gt;lein new app example&lt;/code&gt;. Once that is complete, edit &lt;code&gt;project.clj&lt;/code&gt; so it looks like the following. Be sure to include any other dependencies you will need. The main things to keep an eye on here are the inclusion of &lt;code&gt;lein-cljsbuild&lt;/code&gt; and the paths for &lt;code&gt;:output-to&lt;/code&gt; and &lt;code&gt;:output-dir&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(defproject example &quot;0.1.0-SNAPSHOT&quot;
  :description &quot;FIXME: write description&quot;
  :url &quot;http://example.com/FIXME&quot;
  :license {:name &quot;Eclipse Public License&quot;
            :url &quot;http://www.eclipse.org/legal/epl-v10.html&quot;}
 
  :jvm-opts ^:replace [&quot;-Xmx1g&quot; &quot;-server&quot;]
 
  :dependencies [[org.clojure/clojure &quot;1.6.0&quot;]
                 [org.clojure/clojurescript &quot;0.0-2371&quot;]]
 
  :plugins [[lein-cljsbuild &quot;1.0.3&quot;]]
 
  :source-paths [&quot;src/&quot;]
  :resource-paths [&quot;resources&quot;]
 
  :cljsbuild {
    :builds [{:id &quot;dev&quot;
              :source-paths [&quot;src/&quot;]
              :compiler {
                :output-to &quot;resources/public/scripts/main.js&quot;
                :output-dir &quot;resources/public/scripts/out&quot;
                :optimizations :none
                :source-map true}}]})
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Next, install node and npm if you don&#39;t have them already. For ubuntu/debian based distros, run &lt;code&gt;sudo apt-get install npm&lt;/code&gt;. This will rope in node and all of the other packages you&#39;ll need to get started. Next, install grunt by running &lt;code&gt;sudo npm install -g grunt-cli&lt;/code&gt;. Once you have node, npm, and grunt, create a file called &lt;code&gt;package.json&lt;/code&gt; in your project directory and add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
{
  &quot;name&quot;: &quot;example&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;devDependencies&quot;: {},
  &quot;dependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.5&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.6.1&quot;,
    &quot;grunt-express&quot;: &quot;~1.4.1&quot;,
    &quot;grunt-open&quot;: &quot;~0.2.3&quot;,
    &quot;matchdep&quot;: &quot;~0.3.0&quot;
  },
 &quot;engines&quot;: {
   &quot;node&quot;: &quot;&gt;=0.8.0&quot;
 }
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This file lists the node dependencies you&#39;ll need to enable livereload. Run &lt;code&gt;npm install&lt;/code&gt; in your project directory to install them locally.&lt;/p&gt;

&lt;p&gt;Now for the fun part. Create a file called &lt;code&gt;Gruntfile.js&lt;/code&gt; in your project directory and add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Gruntfile
module.exports = function(grunt) {
 
  require(&#39;matchdep&#39;).filter(&#39;grunt-*&#39;).forEach(grunt.loadNpmTasks);
 
  // Configure Grunt
  grunt.initConfig({
 
      // grunt-express will serve the files from the folders listed in `bases`
      // on specified `port` and `hostname`
      express: {
        all: {
          options: {
            port: 9000,
            hostname: &quot;0.0.0.0&quot;,
            bases: [&#39;resources/public/&#39;],
            livereload: true
          }
        }
      },
 
      // grunt-watch will monitor the projects files
      watch: {
        all: {
          files: [&#39;resources/public/*&#39;,
                  &#39;!**/bower_components/**&#39;],
          options: {
            livereload: true
          }
        }
      },
 
      // grunt-open will open your browser at the project&#39;s URL
      open: {
        all: {
          // Gets the port from the connect configuration
          path: &#39;http://127.0.0.1:&lt;%= express.all.options.port%&gt;&#39;
        }
      }
  });
 
  // Creates the `lein` task
  grunt.registerTask(&#39;lein&#39;, &#39;compile cljs.&#39;, function() {
    var spawn = require(&#39;child_process&#39;).spawn;
    grunt.log.writeln(&#39;Compiling cljs.&#39;);
    var PIPE = {stdio: &#39;inherit&#39;};
    spawn(&#39;lein&#39;, [&#39;cljsbuild&#39;, &#39;auto&#39;], PIPE);
  });
 
 // Creates the `server` task
  grunt.registerTask(&#39;server&#39;, [
    &#39;lein&#39;,
    &#39;express&#39;,
    &#39;open&#39;,
    &#39;watch&#39;
  ]);
};
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This configuration will allow you to compile your clojurescript, automatically open the app in your browser, and recompile/refresh your browser when you make a change.&lt;/p&gt;

&lt;p&gt;Let&#39;s write some really quick clojurescript to get you started.&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;First, in your project directory, run &lt;code&gt;mkdir -p resources/public/scripts&lt;/code&gt; and create a new file at &lt;code&gt;resources/public/index.html&lt;/code&gt;. Make sure your index.html looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script src=&quot;scripts/out/goog/base.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;scripts/main.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;goog.require(&quot;example.core&quot;);&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, create a new file at &lt;code&gt;src/example/core.cljs&lt;/code&gt; and add the following&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(ns example.core)
 
(enable-console-print!)
 
(.log js/console &quot;Hello!&quot;)
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Before you start the livereload, run &lt;code&gt;lein cljsbuild once&lt;/code&gt; so you don&#39;t have to wait for the code to compile when you launch the server for the first time. Once that&#39;s complete, run &lt;code&gt;grunt server&lt;/code&gt; in your project directory and let the grunt magic do the rest. Open the javascript console in your browser and you should see &quot;Hello!&quot;. Modify &lt;code&gt;src/example/core.cljs&lt;/code&gt;, save it, and watch your code compile and refresh in your browser! Pretty cool.&lt;/p&gt;
</description>
      <pubDate>Sun, 19 Oct 2014 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/clojure/grunt-livereload-for-clojurescript.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/clojure/grunt-livereload-for-clojurescript.html</guid>
    </item>
    
  </channel>
</rss>
