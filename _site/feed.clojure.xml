<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tgallant.github.io - clojure</title>
    <description>Posts categorized as 'clojure'</description>
    <link>https://tgallant.github.io</link>
    <atom:link href="https://tgallant.github.io/feed.clojure.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>html5Mode in Angular and Clojure</title>
      <description>&lt;ul&gt;
&lt;li&gt;benefits of angularjs html5mode

&lt;ul&gt;
&lt;li&gt;native looking urls&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;drawbacks of html5mode

&lt;ul&gt;
&lt;li&gt;not sharable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;solutions

&lt;ul&gt;
&lt;li&gt;send all traffic to index.hmtl&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tgallant/angular-seed-clj&quot;&gt;https://github.com/tgallant/angular-seed-clj&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Its probably a purely aesthetic thing, but I'm not a big fan of the
default angularjs urls. I feel having the '#' in there hinders
usability. A project's url structure is more discoverable when it is
familiar to the user. This is where html5Mode can be handy. It will
turn your urls from this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /home/#/dashboard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /home/dashboard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gets us the url structure we want, but these links are in fact
not sharable. If your application is using html5Mode, the url that
shows up in the browser can't be copy and pasted. Instead of bringing
up the requested page it will throw a 404. This is because the server
is not aware that angular is controlling all of the routes. To get
sharable links with html5Mode the server needs to let angular handle
the application routing.&lt;/p&gt;

&lt;p&gt;In nginx this is done by using &lt;code&gt;try_files&lt;/code&gt; like so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
  root /path/to/files;
  try_files $uri $uri/ /index.html;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If nginx doesn't get a valid response from the actual url path, it
will send the request to the index.html file, at which point angularjs
will initialize and handle the url parameters. This is a handy trick
that we can actually implement in our server-side code.&lt;/p&gt;

&lt;p&gt;In compojure this is done by specifying a wildcard route like so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defroutes app-routes
  (GET &quot;/&quot; [] (index-page))
  (GET &quot;/api/repo/&quot; [] (api/repo-info))
  (POST &quot;/api/init/&quot; request (api/new-repo (get-in request [:body :name])))
  (GET &quot;*&quot; [] (index-page))
  (route/resources &quot;/&quot;)
  (route/not-found &quot;Not Found&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In compojure the asterisk stands for the wildcard route. It will match
any route that has not yet been matched. When using wildcards it is
important to put them after all of your defined routes like in the
example above. If a route is defined after the wildcard it will never
be run.&lt;/p&gt;

&lt;p&gt;I really like how this clojure/angularjs html5mode setup separates the
concerns of API routes and application routes. Angular takes care of
all browser facing routes while clojure deals with API routes and
database calls. All of this while maintaining our nice clean URI
structure. Hashtags belong on twitter, not in urls!&lt;/p&gt;

&lt;p&gt;I've put together a github repo with all of this stuff already setup. Check it
out here &lt;a href=&quot;https://github.com/tgallant/angular-seed-clj&quot;&gt;https://github.com/tgallant/angular-seed-clj&lt;/a&gt;.&lt;/p&gt;
</description>
      <pubDate>Tue, 20 Jan 2015 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/clojure/html5Mode-angular-clojure.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/clojure/html5Mode-angular-clojure.html</guid>
    </item>
    
    <item>
      <title>Manage Clojure Processes with supervisord</title>
      <description>&lt;p&gt;Writing init scripts can be a pain and running your apps in tmux or screen sessions, while easier, seems unprofessional. That's where supervisord comes in. Supervisord provides an easy way to define and manage processes. It seems to be more well known in the python world, but it can be used to run any command on your system path.&lt;/p&gt;

&lt;p&gt;Installing supervisord is easy. You can run &lt;code&gt;apt-get install supervisor&lt;/code&gt; or &lt;code&gt;yum install supervisor&lt;/code&gt; if you're on debian/redhat. If your distribution doesn't offer supervisor in it's packcage manager, you can install it via &lt;code&gt;pip install supervisor&lt;/code&gt;. More info about installation can be found &lt;a href=&quot;http://supervisord.org/installing.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To have supervisord manage a ring app, place the following in &lt;code&gt;/etc/supervisor/conf.d&lt;/code&gt;. Be sure to change out the program name, paths, and user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
[program:blog-checker]
command= /usr/local/bin/java -jar target/blog-checker-0.1.0-SNAPSHOT-standalone.jar
directory=/usr/local/www/blog-checker
autostart=true
autorestart=true
startretries=3
user=www
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The above configuration executes &lt;code&gt;/usr/local/bin/java -jar target/blog-checker-0.1.0-SNAPSHOT-standalone.jar&lt;/code&gt; as the user &lt;code&gt;www&lt;/code&gt; in the &lt;code&gt;/usr/local/www/blog-checker&lt;/code&gt; directory. Lines 4-6 set this app to be run at startup and to autorestart if it fails.&lt;/p&gt;

&lt;p&gt;To start the app, run &lt;code&gt;supervisorctl reread &amp;amp;&amp;amp; supervisorctl update &amp;amp;&amp;amp; supervisorctl start &amp;lt;your_app_name_here&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also run &lt;code&gt;supervisorctl status&lt;/code&gt; to check the status of your app or &lt;code&gt;supervisorctl restart &amp;lt;your_app_name_here&amp;gt;&lt;/code&gt; to restart it.&lt;/p&gt;
</description>
      <pubDate>Sat, 01 Nov 2014 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/clojure/supervisord-with-clojure.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/clojure/supervisord-with-clojure.html</guid>
    </item>
    
    <item>
      <title>Grunt Livereload for Clojurescript</title>
      <description>&lt;p&gt;&lt;a href=&quot;https://github.com/tgallant/cljs-livereload-example/blob/master/Gruntfile.js&quot;&gt;Link to Gruntfile.js if you know what you're doing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The front-end tooling ecosystem that has emerged around node allows for many modern niceties like npm, bower, and grunt. As helpful as these tools can be, they can also bring about a boiling, unfathomable rage when they stop working or, perhaps, don't work at all. See the following tweet from Joe Armstrong, creator of erlang and all-around badass&lt;/p&gt;

&lt;center&gt;
&lt;blockquote class=&quot;twitter-tweet&quot; lang=&quot;en&quot;&gt;&lt;p&gt;&amp;quot;Unable to find local grunt&amp;quot; - but I just installed grunt - Aaaaaaggggg - &amp;#10;having a bad day ...&lt;/p&gt;&amp;mdash; Joe Armstrong (@joeerl) &lt;a href=&quot;https://twitter.com/joeerl/status/505337612513853441&quot;&gt;August 29, 2014&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/center&gt;


&lt;p&gt;Joe's Gruntrage&amp;trade; led him to mention this experience in his aptly titled talk, &lt;a href=&quot;https://www.youtube.com/watch?v=lKXe3HUG2l4&quot;&gt;The Mess We're In&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, this isn't a post about bashing grunt or node. I actually advocate for their use and think grunt can allow for some pretty awesome clojurescript workflows. I will show you how to get started with a livereload clojurescript workflow and make sure you don't have any &quot;bad days.&quot;&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/tgallant/cljs-livereload-example&quot;&gt;Here&lt;/a&gt; is a working github repo if you need help or just want to get started right away.&lt;/p&gt;

&lt;p&gt;Start by creating a new clojure project by running &lt;code&gt;lein new app example&lt;/code&gt;. Once that is complete, edit &lt;code&gt;project.clj&lt;/code&gt; so it looks like the following. Be sure to include any other dependencies you will need. The main things to keep an eye on here are the inclusion of &lt;code&gt;lein-cljsbuild&lt;/code&gt; and the paths for &lt;code&gt;:output-to&lt;/code&gt; and &lt;code&gt;:output-dir&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(defproject example &quot;0.1.0-SNAPSHOT&quot;
  :description &quot;FIXME: write description&quot;
  :url &quot;http://example.com/FIXME&quot;
  :license {:name &quot;Eclipse Public License&quot;
            :url &quot;http://www.eclipse.org/legal/epl-v10.html&quot;}
 
  :jvm-opts ^:replace [&quot;-Xmx1g&quot; &quot;-server&quot;]
 
  :dependencies [[org.clojure/clojure &quot;1.6.0&quot;]
                 [org.clojure/clojurescript &quot;0.0-2371&quot;]]
 
  :plugins [[lein-cljsbuild &quot;1.0.3&quot;]]
 
  :source-paths [&quot;src/&quot;]
  :resource-paths [&quot;resources&quot;]
 
  :cljsbuild {
    :builds [{:id &quot;dev&quot;
              :source-paths [&quot;src/&quot;]
              :compiler {
                :output-to &quot;resources/public/scripts/main.js&quot;
                :output-dir &quot;resources/public/scripts/out&quot;
                :optimizations :none
                :source-map true}}]})
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Next, install node and npm if you don't have them already. For ubuntu/debian based distros, run &lt;code&gt;sudo apt-get install npm&lt;/code&gt;. This will rope in node and all of the other packages you'll need to get started. Next, install grunt by running &lt;code&gt;sudo npm install -g grunt-cli&lt;/code&gt;. Once you have node, npm, and grunt, create a file called &lt;code&gt;package.json&lt;/code&gt; in your project directory and add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
{
  &quot;name&quot;: &quot;example&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;devDependencies&quot;: {},
  &quot;dependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.5&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.6.1&quot;,
    &quot;grunt-express&quot;: &quot;~1.4.1&quot;,
    &quot;grunt-open&quot;: &quot;~0.2.3&quot;,
    &quot;matchdep&quot;: &quot;~0.3.0&quot;
  },
 &quot;engines&quot;: {
   &quot;node&quot;: &quot;&gt;=0.8.0&quot;
 }
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This file lists the node dependencies you'll need to enable livereload. Run &lt;code&gt;npm install&lt;/code&gt; in your project directory to install them locally.&lt;/p&gt;

&lt;p&gt;Now for the fun part. Create a file called &lt;code&gt;Gruntfile.js&lt;/code&gt; in your project directory and add the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
// Gruntfile
module.exports = function(grunt) {
 
  require('matchdep').filter('grunt-*').forEach(grunt.loadNpmTasks);
 
  // Configure Grunt
  grunt.initConfig({
 
      // grunt-express will serve the files from the folders listed in `bases`
      // on specified `port` and `hostname`
      express: {
        all: {
          options: {
            port: 9000,
            hostname: &quot;0.0.0.0&quot;,
            bases: ['resources/public/'],
            livereload: true
          }
        }
      },
 
      // grunt-watch will monitor the projects files
      watch: {
        all: {
          files: ['resources/public/*',
                  '!**/bower_components/**'],
          options: {
            livereload: true
          }
        }
      },
 
      // grunt-open will open your browser at the project's URL
      open: {
        all: {
          // Gets the port from the connect configuration
          path: 'http://127.0.0.1:&lt;%= express.all.options.port%&gt;'
        }
      }
  });
 
  // Creates the `lein` task
  grunt.registerTask('lein', 'compile cljs.', function() {
    var spawn = require('child_process').spawn;
    grunt.log.writeln('Compiling cljs.');
    var PIPE = {stdio: 'inherit'};
    spawn('lein', ['cljsbuild', 'auto'], PIPE);
  });
 
 // Creates the `server` task
  grunt.registerTask('server', [
    'lein',
    'express',
    'open',
    'watch'
  ]);
};
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This configuration will allow you to compile your clojurescript, automatically open the app in your browser, and recompile/refresh your browser when you make a change.&lt;/p&gt;

&lt;p&gt;Let's write some really quick clojurescript to get you started.&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;First, in your project directory, run &lt;code&gt;mkdir -p resources/public/scripts&lt;/code&gt; and create a new file at &lt;code&gt;resources/public/index.html&lt;/code&gt;. Make sure your index.html looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script src=&quot;scripts/out/goog/base.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;scripts/main.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;goog.require(&quot;example.core&quot;);&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, create a new file at &lt;code&gt;src/example/core.cljs&lt;/code&gt; and add the following&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
(ns example.core)
 
(enable-console-print!)
 
(.log js/console &quot;Hello!&quot;)
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Before you start the livereload, run &lt;code&gt;lein cljsbuild once&lt;/code&gt; so you don't have to wait for the code to compile when you launch the server for the first time. Once that's complete, run &lt;code&gt;grunt server&lt;/code&gt; in your project directory and let the grunt magic do the rest. Open the javascript console in your browser and you should see &quot;Hello!&quot;. Modify &lt;code&gt;src/example/core.cljs&lt;/code&gt;, save it, and watch your code compile and refresh in your browser! Pretty cool.&lt;/p&gt;
</description>
      <pubDate>Sun, 19 Oct 2014 00:00:00 -0700</pubDate>
      <link>https://tgallant.github.io/clojure/grunt-livereload-for-clojurescript.html</link>
      <guid isPermaLink="true">https://tgallant.github.io/clojure/grunt-livereload-for-clojurescript.html</guid>
    </item>
    
  </channel>
</rss>
